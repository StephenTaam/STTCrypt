<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8"/>
<title>STTCrypt Web</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="icon" type="image/png" href="../imags/favicon.png">
<style>
body {
  margin:0;
  padding:0;
  background:#f3f4f7;
  font-family:"Segoe UI","Microsoft YaHei",sans-serif;
  color:#222;
}
.container {
  max-width:880px;
  margin:40px auto;
  background:#fff;
  padding:32px 36px 40px;
  border-radius:18px;
  box-shadow:0 8px 25px rgba(0,0,0,0.14);
}
h1{text-align:center;font-size:2.4rem;margin:0 0 8px;font-weight:800;}
.subtitle{text-align:center;color:#666;margin-bottom:20px;font-size:.95rem;}

h2{
  margin-top:26px;margin-bottom:12px;
  font-size:1.4rem;border-left:4px solid #4a90e2;
  padding-left:8px;color:#333;
}

textarea,input[type="text"],input[type="password"]{
  width:100%;padding:10px 12px;
  border-radius:10px;border:1px solid #ccc;
  font-size:1rem;outline:none;resize:vertical;
}
textarea:focus,input:focus{
  border-color:#4a90e2;
  box-shadow:0 0 0 2px rgba(74,144,226,0.2);
}

button{
  padding:10px 22px;border:none;border-radius:10px;
  background:#4a90e2;color:#fff;font-size:.95rem;
  cursor:pointer;margin:6px 8px 0 0;
  box-shadow:0 4px 12px rgba(74,144,226,0.45);
}
button:hover{background:#357ab7;}

.file-box{
  padding:14px 16px 18px;background:#fafafa;
  border-radius:12px;border:1px solid #ddd;margin-top:6px;
}
label{display:block;margin-top:8px;margin-bottom:4px;font-size:.9rem;color:#444;}
.small-hint{font-size:.8rem;color:#888;margin-top:2px;}

/* æ–°å¢ï¼šå¯†ç è¡Œå¸ƒå±€ + å°æŒ‰é’®æ ·å¼ */
.pwd-row{
  display:flex;
  align-items:center;
  gap:8px;
}
.pwd-row input[type="password"],
.pwd-row input[type="text"]{
  flex:1;
}
.icon-btn{
  padding:8px 10px;
  border-radius:8px;
  background:#e5e8f0;
  color:#333;
  font-size:.85rem;
  box-shadow:none;
  min-width:40px;
}
.icon-btn:hover{
  background:#d0d5e5;
}

/* æ–°å¢ï¼šå¯†ç å¼ºåº¦æ˜¾ç¤º */
.pwd-strength{
  font-size:.8rem;
  margin-top:4px;
}

/* æ–°å¢ï¼šè¿›åº¦æ¡ */
.progress-box{
  margin-top:24px;
  padding:12px 14px;
  border-radius:10px;
  background:#f7f8fb;
  border:1px solid #d8ddef;
  display:none;
}
.progress-label{
  font-size:.85rem;
  margin-bottom:6px;
  color:#555;
}
.progress-bar{
  width:100%;
  height:8px;
  border-radius:999px;
  background:#e0e4f0;
  overflow:hidden;
}
.progress-inner{
  height:100%;
  width:0%;
  border-radius:999px;
  background:linear-gradient(90deg,#4a90e2,#27ae60);
  transition:width .18s linear;
}

.toast {
  position: fixed;
  left: 50%;
  bottom: 60px;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.75);
  color: #fff;
  padding: 10px 18px;
  border-radius: 10px;
  font-size: 0.9rem;
  opacity: 0;
  pointer-events: none;
  transition: opacity .3s;
  z-index: 9999;
}
.toast.show {
  opacity: 1;
}
</style>

<div id="toast" class="toast">å¤åˆ¶æˆåŠŸ</div>


</head>
<body>
<div class="container">

<h1>STTCrypt Web</h1>
<div class="subtitle">
ä½ çš„éšç§ï¼Œåªå±äºä½ ã€‚
</div>

<!-- æ–‡æœ¬ -->
<h2>ğŸ” æ–‡æœ¬åŠ å¯† / è§£å¯†</h2>

<label>è¾“å…¥æ˜æ–‡ï¼ˆåŠ å¯†ï¼‰æˆ– Base64 å¯†æ–‡ï¼ˆè§£å¯†ï¼‰</label>
<textarea id="text_in" rows="5"></textarea>

<label>å¯†ç ï¼š</label>
<div class="pwd-row">
  <input type="password" id="pwd_text"/>
  <button type="button" class="icon-btn btn-toggle-pwd" data-target="pwd_text">ğŸ‘</button>
  <button type="button" class="icon-btn" id="gen_pwd_text">ğŸ²</button>
</div>
<div class="pwd-strength" id="pwd_text_strength"></div>

<div style="margin-top:8px;">
  <button id="btn_text_enc">åŠ å¯†æ–‡æœ¬</button>
  <button id="btn_text_dec">è§£å¯†æ–‡æœ¬</button>
</div>

<label style="margin-top:12px;">è¾“å‡ºï¼š</label>
<textarea id="text_out" rows="5" onclick="this.select()"></textarea>
<label style="margin-top:12px;">è¾“å‡ºï¼š</label>
<div style="position: relative;">
    <textarea id="text_out" rows="5" readonly onclick="this.select()"></textarea>
    <button id="btn_copy" type="button" class="icon-btn"
            style="position:absolute; right:4px; bottom:4px; padding:6px 10px;">
        å¤åˆ¶
    </button>
</div>



<!-- æ–‡ä»¶ -->
<h2>ğŸ—‚ æ–‡ä»¶åŠ å¯† / è§£å¯†</h2>

<div class="file-box">

  <label>é€‰æ‹©æ–‡ä»¶ï¼š</label>
  <input type="file" id="file_in"/>

  <label>å¯†ç ï¼š</label>
  <div class="pwd-row">
    <input type="password" id="pwd_file"/>
    <button type="button" class="icon-btn btn-toggle-pwd" data-target="pwd_file">ğŸ‘</button>
    <button type="button" class="icon-btn" id="gen_pwd_file">ğŸ²</button>
  </div>
  <div class="pwd-strength" id="pwd_file_strength"></div>

  <label>ä¿å­˜æ–‡ä»¶åï¼ˆå¯é€‰ï¼‰ï¼š</label>
  <input type="text" id="file_out_name" placeholder="ç•™ç©ºåˆ™é»˜è®¤ç”¨åŸæ–‡ä»¶å"/>
  <div class="small-hint">
    åŠ å¯†åçš„æ–‡ä»¶åå¯ä»¥ä»»æ„ã€æœ‰æ— åç¼€éƒ½å¯ä»¥ï¼›è§£å¯†æ—¶ä¼šæ ¹æ®åŸæ–‡ä»¶ç±»å‹è‡ªåŠ¨è¡¥åç¼€ã€‚
  </div>

  <div style="margin-top:8px;">
    <button id="btn_file_enc">åŠ å¯†æ–‡ä»¶</button>
    <button id="btn_file_dec">è§£å¯†æ–‡ä»¶</button>
  </div>
</div>

<!-- æ–°å¢ï¼šç»Ÿä¸€çš„è¿›åº¦æ˜¾ç¤ºåŒºåŸŸ -->
<div id="progress_box" class="progress-box">
  <div id="progress_label" class="progress-label">å¤„ç†ä¸­...</div>
  <div class="progress-bar">
    <div id="progress_inner" class="progress-inner"></div>
  </div>
</div>

<div style="margin-top:6px;font-size:0.85rem;color:#555;">
    æ— æ³•é€šè¿‡å®‰å…¨ä¿å¯†æ¸ é“å’Œå¯¹æ–¹ç¡®å®šå¯†ç ï¼Ÿ
    <a href="safe_exchange.html" style="color:#4a90e2;text-decoration:underline;" target="_blank">
      ç‚¹è¿™é‡Œä½¿ç”¨â€œå®‰å…¨åå•†æ¨¡å¼â€ï¼ˆä¸€æ­¥ä¸€æ­¥æ•™ä½ å’Œå¯¹æ–¹ä¸€èµ·ç”Ÿæˆå¯†ç ï¼‰
    </a>
  </div>

</div>

<script>
  function showToast(msg) {
    const t = document.getElementById("toast");
    t.textContent = msg;
    t.classList.add("show");
    setTimeout(() => t.classList.remove("show"), 1500);
}

document.getElementById("btn_copy").onclick = async () => {
    const text = document.getElementById("text_out").value;
    if (!text) {
        showToast("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹");
        return;
    }

    try {
        await navigator.clipboard.writeText(text);
        showToast("å¤åˆ¶æˆåŠŸ");
    } catch (err) {
        // éƒ¨åˆ†æµè§ˆå™¨ä¸æ”¯æŒ clipboard â†’ é€€å›æ‰‹åŠ¨é€‰ä¸­æ–¹å¼
        const ta = document.getElementById("text_out");
        ta.select();
        showToast("å·²é€‰ä¸­ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
    }
};

// ============================
// å¸¸é‡ï¼ˆä¸ C++ å®Œå…¨ä¸€è‡´ï¼‰
// ============================
const SALT_LEN = 16;
const IV_LEN   = 12;
const TAG_LEN  = 16;
const PBKDF2_ITERS = 200000;


// ============================
// Base64 å·¥å…·ï¼ˆç”¨äºæ–‡æœ¬æ¨¡å¼ï¼‰
// ============================
function bytesToBase64(bytes){
  let bin="";
  for(let i=0;i<bytes.length;i++)
    bin+=String.fromCharCode(bytes[i]);
  return btoa(bin);
}

function base64ToBytes(b64){
  b64=b64.replace(/\s+/g,"");
  const bin=atob(b64);
  const len=bin.length;
  const out=new Uint8Array(len);
  for(let i=0;i<len;i++) out[i]=bin.charCodeAt(i);
  return out;
}


// ============================
// KDF: PBKDF2-SHA256
// ============================
async function deriveKey(password,salt){
  const enc=new TextEncoder();
  const keyMaterial=await crypto.subtle.importKey(
    "raw",enc.encode(password),{name:"PBKDF2"},false,["deriveBits"]
  );

  const bits=await crypto.subtle.deriveBits(
    {
      name:"PBKDF2",
      salt:salt,
      iterations:PBKDF2_ITERS,
      hash:"SHA-256"
    },
    keyMaterial,
    256
  );
  return new Uint8Array(bits);
}

async function importAesKey(rawBytes){
  return crypto.subtle.importKey("raw",rawBytes,{name:"AES-GCM"},false,["encrypt","decrypt"]);
}


// ============================
// æ–°å¢ï¼šå¯†ç å¼ºåº¦æ£€æµ‹
// ============================
function getPasswordStrength(pwd){
  if(!pwd) return {level:"empty", color:"#888", text:""};
  let score = 0;
  if(pwd.length >= 8)  score++;
  if(pwd.length >= 12) score++;
  if(pwd.length >= 16) score++;
  if(/[a-z]/.test(pwd) && /[A-Z]/.test(pwd)) score++;
  if(/\d/.test(pwd)) score++;
  if(/[^A-Za-z0-9]/.test(pwd)) score++;
  if(pwd.length >= 20) score++;

  let level, color, text;
  if(score <= 2){
    level = "weak";
    color = "#e74c3c"; // çº¢
    text  = "å¼±";
  }else if(score <= 4){
    level = "medium";
    color = "#f1c40f"; // é»„
    text  = "ä¸­";
  }else{
    level = "strong";
    color = "#27ae60"; // ç»¿
    text  = "å¼º";
  }
  return {level, color, text};
}

function updateStrength(inputId, strengthId){
  const pwd = document.getElementById(inputId).value;
  const el  = document.getElementById(strengthId);
  const s   = getPasswordStrength(pwd);
  if(!pwd){
    el.textContent = "";
    el.style.color = "#888";
    return;
  }
  el.textContent = "å¯†ç å¼ºåº¦ï¼š" + s.text;
  el.style.color = s.color;
}

// ç»‘å®šè¾“å…¥äº‹ä»¶
document.addEventListener("DOMContentLoaded", () => {
  const pwdText = document.getElementById("pwd_text");
  const pwdFile = document.getElementById("pwd_file");
  if(pwdText){
    pwdText.addEventListener("input", () => updateStrength("pwd_text","pwd_text_strength"));
  }
  if(pwdFile){
    pwdFile.addEventListener("input", () => updateStrength("pwd_file","pwd_file_strength"));
  }
});

// ============================
// æ–°å¢ï¼šå¯†ç æ˜¾ç¤º / éšè—åˆ‡æ¢
// ============================
function togglePasswordVisibility(inputId){
  const input = document.getElementById(inputId);
  if(!input) return;
  input.type = (input.type === "password") ? "text" : "password";
}

document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".btn-toggle-pwd").forEach(btn => {
    btn.addEventListener("click", () => {
      const target = btn.getAttribute("data-target");
      togglePasswordVisibility(target);
    });
  });
});

// ============================
// æ–°å¢ï¼šéšæœºå¼ºå¯†ç ç”Ÿæˆ
// ============================
function generateStrongPassword(len = 20){
  const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+[]{};:,.<>?/|~";
  const arr = new Uint32Array(len);
  crypto.getRandomValues(arr);
  let pwd = "";
  for(let i=0;i<len;i++){
    pwd += charset[arr[i] % charset.length];
  }
  return pwd;
}

function applyGeneratedPassword(inputId, strengthId){
  const pwd = generateStrongPassword(20);
  const input = document.getElementById(inputId);
  input.value = pwd;
  updateStrength(inputId, strengthId);
}

document.addEventListener("DOMContentLoaded", () => {
  const genText = document.getElementById("gen_pwd_text");
  const genFile = document.getElementById("gen_pwd_file");
  if(genText){
    genText.addEventListener("click", () => {
      applyGeneratedPassword("pwd_text","pwd_text_strength");
    });
  }
  if(genFile){
    genFile.addEventListener("click", () => {
      applyGeneratedPassword("pwd_file","pwd_file_strength");
    });
  }
});


// ============================
// æ–°å¢ï¼šè¿›åº¦æ˜¾ç¤ºï¼ˆæ¨¡æ‹Ÿè¿›åº¦ï¼‰
// ============================
let progressTimer = null;
let progressValue = 0;

function showProgress(label){
  const box   = document.getElementById("progress_box");
  const labEl = document.getElementById("progress_label");
  const inner = document.getElementById("progress_inner");
  if(!box || !labEl || !inner) return;

  labEl.textContent = label || "å¤„ç†ä¸­...";
  box.style.display = "block";
  progressValue = 0;
  inner.style.width = "0%";

  if(progressTimer){
    clearInterval(progressTimer);
    progressTimer = null;
  }
  // ç®€å•æ¨¡æ‹Ÿï¼šæ¯ 150ms å¢åŠ  4%ï¼Œæœ€å¤šåˆ° 90%
  progressTimer = setInterval(() => {
    if(progressValue < 90){
      progressValue += 4;
      inner.style.width = progressValue + "%";
    }
  }, 150);
}

function completeProgress(){
  const box   = document.getElementById("progress_box");
  const inner = document.getElementById("progress_inner");
  if(!box || !inner) return;

  if(progressTimer){
    clearInterval(progressTimer);
    progressTimer = null;
  }
  progressValue = 100;
  inner.style.width = "100%";
  // ç¨å¾®åœä¸€ä¸‹å†éšè—
  setTimeout(() => {
    box.style.display = "none";
    inner.style.width = "0%";
    progressValue = 0;
  }, 400);
}

function resetProgressOnError(){
  const box   = document.getElementById("progress_box");
  const inner = document.getElementById("progress_inner");
  if(!box || !inner) return;

  if(progressTimer){
    clearInterval(progressTimer);
    progressTimer = null;
  }
  box.style.display = "none";
  inner.style.width = "0%";
  progressValue = 0;
}


// ============================
// æ–‡æœ¬åŠ å¯†ï¼ˆsalt|iv|tag|ciphertext â†’ Base64ï¼‰
// ============================
async function encryptText(plain,password){
  const enc=new TextEncoder();
  const plainBytes=enc.encode(plain);

  const salt=crypto.getRandomValues(new Uint8Array(SALT_LEN));
  const iv  =crypto.getRandomValues(new Uint8Array(IV_LEN));
  const keyBytes=await deriveKey(password,salt);
  const aesKey=await importAesKey(keyBytes);

  const encrypted=await crypto.subtle.encrypt(
    {name:"AES-GCM",iv},
    aesKey,
    plainBytes
  );

  // WebCrypto è¾“å‡º: ciphertext||tagï¼ˆtag åœ¨æœ«å°¾ï¼‰
  const outAll=new Uint8Array(encrypted);
  const ciphertext = outAll.slice(0,outAll.length - TAG_LEN);
  const tag        = outAll.slice(outAll.length - TAG_LEN);

  // æ–‡æœ¬æ ¼å¼çº¦å®šï¼šsalt | iv | tag | ciphertext
  const out=new Uint8Array(SALT_LEN + IV_LEN + TAG_LEN + ciphertext.length);
  let o=0;
  out.set(salt,o); o+=SALT_LEN;
  out.set(iv,o);   o+=IV_LEN;
  out.set(tag,o);  o+=TAG_LEN;
  out.set(ciphertext,o);

  return bytesToBase64(out);
}


// ============================
// æ–‡æœ¬è§£å¯†ï¼ˆsalt|iv|tag|ciphertext Base64ï¼‰
// ============================
async function decryptText(b64,password){
  const all=base64ToBytes(b64);

  if(all.length < SALT_LEN+IV_LEN+TAG_LEN)
    throw new Error("å¯†æ–‡è¿‡çŸ­");

  let o=0;
  const salt=all.slice(o,o+SALT_LEN); o+=SALT_LEN;
  const iv  =all.slice(o,o+IV_LEN);   o+=IV_LEN;
  const tag =all.slice(o,o+TAG_LEN);  o+=TAG_LEN;

  const ciphertext=all.slice(o);

  // è¿˜åŸæˆ WebCrypto éœ€è¦çš„ ciphertext||tag
  const combined=new Uint8Array(ciphertext.length + TAG_LEN);
  combined.set(ciphertext,0);
  combined.set(tag,ciphertext.length);

  const keyBytes=await deriveKey(password,salt);
  const aesKey =await importAesKey(keyBytes);

  const plainBuf=await crypto.subtle.decrypt(
    {name:"AES-GCM",iv},
    aesKey,
    combined
  );
  return new TextDecoder().decode(plainBuf);
}


// ============================
// æ–‡ä»¶åŠ å¯†ï¼ˆsalt|iv|ciphertext|tagï¼Œä¸ C++ æ–‡ä»¶ä¸€è‡´ï¼‰
// ============================
async function encryptFileBytes(bytes, password) {
  const salt = crypto.getRandomValues(new Uint8Array(SALT_LEN));
  const iv   = crypto.getRandomValues(new Uint8Array(IV_LEN));
  const keyBytes = await deriveKey(password, salt);
  const aesKey   = await importAesKey(keyBytes);

  // WebCryptoï¼šciphertext||tag
  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    aesKey,
    bytes
  );
  const encAll = new Uint8Array(encrypted); // [ciphertext || tag]

  // C++ æ–‡ä»¶æ ¼å¼ï¼šsalt | iv | ciphertext | tag
  const out = new Uint8Array(SALT_LEN + IV_LEN + encAll.length);
  let o = 0;
  out.set(salt, o); o += SALT_LEN;
  out.set(iv,   o); o += IV_LEN;
  out.set(encAll, o);

  return out;
}


// ============================
// æ–‡ä»¶è§£å¯†ï¼ˆä¸ C++ æ–‡ä»¶æ ¼å¼äº’é€šï¼‰
// ============================
async function decryptFileBytes(all, password) {
  if (all.length < SALT_LEN + IV_LEN + TAG_LEN) {
    throw new Error("æ–‡ä»¶ä¸å®Œæ•´");
  }

  let o = 0;
  const salt = all.slice(o, o + SALT_LEN); o += SALT_LEN;
  const iv   = all.slice(o, o + IV_LEN);   o += IV_LEN;

  // å‰©ä¸‹çš„æ˜¯ ciphertext | tag
  const encAll = all.slice(o);
  if (encAll.length < TAG_LEN) {
    throw new Error("æ–‡ä»¶ä¸å®Œæ•´");
  }

  const cipherLen  = encAll.length - TAG_LEN;
  const ciphertext = encAll.slice(0, cipherLen);
  const tag        = encAll.slice(cipherLen);

  // è¿˜åŸä¸º WebCrypto éœ€è¦çš„æ ¼å¼ï¼šciphertext||tag
  const combined = new Uint8Array(ciphertext.length + TAG_LEN);
  combined.set(ciphertext, 0);
  combined.set(tag, ciphertext.length);

  const keyBytes = await deriveKey(password, salt);
  const aesKey   = await importAesKey(keyBytes);

  const plainBuf = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv },
    aesKey,
    combined
  );
  return new Uint8Array(plainBuf);
}


// ============================
// æ ¹æ®æ–‡ä»¶é­”æ•°çŒœåç¼€ï¼ˆè‡ªåŠ¨ç±»å‹è¯†åˆ«ï¼‰
// ============================
function detectFileExtension(bytes) {
  const len = bytes.length;
  const b = (i) => (i < len ? bytes[i] : 0);

  // PNG
  if (len >= 8 &&
      b(0) === 0x89 && b(1) === 0x50 && b(2) === 0x4E && b(3) === 0x47 &&
      b(4) === 0x0D && b(5) === 0x0A && b(6) === 0x1A && b(7) === 0x0A) {
    return ".png";
  }

  // JPEG
  if (len >= 3 && b(0) === 0xFF && b(1) === 0xD8 && b(2) === 0xFF) {
    return ".jpg";
  }

  // GIF
  if (len >= 4 &&
      b(0) === 0x47 && b(1) === 0x49 && b(2) === 0x46 && b(3) === 0x38) {
    return ".gif";
  }

  // PDF
  if (len >= 4 &&
      b(0) === 0x25 && b(1) === 0x50 && b(2) === 0x44 && b(3) === 0x46) { // %PDF
    return ".pdf";
  }

  // ZIP / Office / JAR ç­‰ï¼ˆç»Ÿä¸€å½“ zipï¼‰
  if (len >= 4 &&
      b(0) === 0x50 && b(1) === 0x4B &&
      (b(2) === 0x03 || b(2) === 0x05 || b(2) === 0x07) &&
      (b(3) === 0x04 || b(3) === 0x06 || b(3) === 0x08)) {
    return ".zip";
  }

  // RAR
  if (len >= 7 &&
      b(0) === 0x52 && b(1) === 0x61 && b(2) === 0x72 &&
      b(3) === 0x21 && b(4) === 0x1A && b(5) === 0x07) {
    return ".rar";
  }

  // 7z
  if (len >= 6 &&
      b(0) === 0x37 && b(1) === 0x7A && b(2) === 0xBC &&
      b(3) === 0xAF && b(4) === 0x27 && b(5) === 0x1C) {
    return ".7z";
  }

  // MP4 / MOV (ftyp)
  if (len >= 12 &&
      b(4) === 0x66 && b(5) === 0x74 && b(6) === 0x79 && b(7) === 0x70) {
    return ".mp4";
  }

  // WebM / Matroska
  if (len >= 4 &&
      b(0) === 0x1A && b(1) === 0x45 && b(2) === 0xDF && b(3) === 0xA3) {
    return ".mkv";
  }

  // RIFF å®¹å™¨ï¼ˆWAV/WEBP/AVIï¼‰
  if (len >= 12 &&
      b(0) === 0x52 && b(1) === 0x49 && b(2) === 0x46 && b(3) === 0x46) { // 'RIFF'
    // WAVE
    if (b(8) === 0x57 && b(9) === 0x41 && b(10) === 0x56 && b(11) === 0x45) {
      return ".wav";
    }
    // WEBP
    if (b(8) === 0x57 && b(9) === 0x45 && b(10) === 0x42 && b(11) === 0x50) {
      return ".webp";
    }
    // å…¶ä»– RIFFï¼Œå½“ .avi å¤„ç†
    return ".avi";
  }

  // MP3 (ç®€å•åˆ¤æ–­ï¼šID3 tag)
  if (len >= 3 && b(0) === 0x49 && b(1) === 0x44 && b(2) === 0x33) {
    return ".mp3";
  }

  // OGG
  if (len >= 4 &&
      b(0) === 0x4F && b(1) === 0x67 && b(2) === 0x67 && b(3) === 0x53) {
    return ".ogg";
  }

  // æ–‡æœ¬æ–‡ä»¶ï¼ˆç®€å•åˆ¤æ–­ï¼šå‰è‹¥å¹²å­—èŠ‚éƒ½æ˜¯å¯æ‰“å° ASCIIï¼‰
  const sample = Math.min(len, 256);
  let textLike = true;
  for (let i = 0; i < sample; i++) {
    const c = bytes[i];
    // å…è®¸ï¼š\n \r \t ä»¥åŠ 0x20~0x7E æ™®é€š ASCII
    if (c === 0x09 || c === 0x0A || c === 0x0D) continue;
    if (c < 0x20 || c > 0x7E) { textLike = false; break; }
  }
  if (textLike) {
    return ".txt";
  }

  // å®åœ¨è¯†åˆ«ä¸äº†å°±å½“ .bin
  return ".bin";
}


// ============================
// æ–‡æœ¬æŒ‰é’®äº‹ä»¶
// ============================
document.getElementById("btn_text_enc").onclick=async()=>{
  const plain=document.getElementById("text_in").value;
  const pwd  =document.getElementById("pwd_text").value;
  if(!pwd){ alert("è¯·è¾“å…¥å¯†ç "); return; }

  try{
    showProgress("æ­£åœ¨åŠ å¯†æ–‡æœ¬...");
    const b64=await encryptText(plain,pwd);
    document.getElementById("text_out").value=b64;
    completeProgress();
  }catch(e){
    resetProgressOnError();
    alert("åŠ å¯†å¤±è´¥ï¼š"+e.message);
  }
};

document.getElementById("btn_text_dec").onclick=async()=>{
  const b64=document.getElementById("text_in").value;
  const pwd=document.getElementById("pwd_text").value;
  if(!pwd){ alert("è¯·è¾“å…¥å¯†ç "); return; }

  try{
    const plain=await decryptText(b64,pwd);
    document.getElementById("text_out").value=plain;
  }catch(e){
    alert("è§£å¯†å¤±è´¥ï¼š"+e.message);
  }
};


// ============================
// æ–‡ä»¶æŒ‰é’®äº‹ä»¶
// ============================
document.getElementById("btn_file_enc").onclick=async()=>{
  const f=document.getElementById("file_in").files[0];
  const pwd=document.getElementById("pwd_file").value;
  const outNameInput = document.getElementById("file_out_name").value.trim();

  if(!f){ alert("è¯·é€‰æ‹©æ–‡ä»¶"); return; }
  if(!pwd){ alert("è¯·è¾“å…¥å¯†ç "); return; }

  try {
    showProgress("æ­£åœ¨åŠ å¯†æ–‡ä»¶...");
    const buf=new Uint8Array(await f.arrayBuffer());
    const out=await encryptFileBytes(buf,pwd);

    const a=document.createElement("a");
    const blob = new Blob([out],{type:"application/octet-stream"});
    a.href=URL.createObjectURL(blob);

    // åŠ å¯†è¾“å‡ºæ–‡ä»¶åï¼š
    // 1. è‹¥ç”¨æˆ·æŒ‡å®šï¼Œåˆ™ç”¨ç”¨æˆ·ç»™çš„
    // 2. å¦åˆ™ç”¨åŸæ–‡ä»¶åï¼ˆä¸å¼ºåˆ¶åŠ  .encï¼Œä½ å¯è‡ªå·±æ”¹å/å»æ‰åç¼€ï¼‰
    let name = outNameInput || f.name;
    if (!name) name = "encrypted.bin";

    a.download = name;
    a.click();
    URL.revokeObjectURL(a.href);
    completeProgress();
  } catch (e) {
    console.error(e);
    resetProgressOnError();
    alert("æ–‡ä»¶åŠ å¯†å¤±è´¥ï¼š" + e.message);
  }
};

document.getElementById("btn_file_dec").onclick = async () => {
  const f = document.getElementById("file_in").files[0];
  const pwd = document.getElementById("pwd_file").value;
  const outNameInput = document.getElementById("file_out_name").value.trim();

  if (!f) return alert("è¯·é€‰æ‹©åŠ å¯†åçš„æ–‡ä»¶");
  if (!pwd) return alert("è¯·è¾“å…¥å¯†ç ");

  try {
    const all = new Uint8Array(await f.arrayBuffer());
    const plainBytes = await decryptFileBytes(all, pwd);

    // 1. æ ¹æ®å†…å®¹è‡ªåŠ¨è¯†åˆ«åç¼€ï¼ˆé­”æ•°ï¼‰
    const ext = detectFileExtension(plainBytes);

    // 2. åŸºç¡€æ–‡ä»¶åï¼š
    //    - è‹¥ç”¨æˆ·æŒ‡å®šï¼Œåˆ™ç”¨ç”¨æˆ·ç»™çš„ï¼ˆä¸å«åç¼€æ—¶å†åŠ  extï¼‰
    //    - å¦åˆ™å–è¾“å…¥æ–‡ä»¶åå»æ‰ .enc / å…¶å®ƒå°¾ç¼€
    let base;
    if (outNameInput) {
      // ç”¨æˆ·å†™çš„å¦‚æœå·²ç»å¸¦åç¼€ï¼Œå°±ç›´æ¥ç”¨ï¼›å¦åˆ™åé¢åŠ  ext
      const hasDot = outNameInput.lastIndexOf(".") > 0;
      base = outNameInput;
      if (!hasDot) {
        base = outNameInput; // åé¢å†æ‹¼ ext
      }
    } else {
      // ç”¨è¾“å…¥æ–‡ä»¶ååšåŸºå
      base = f.name.replace(/(\.enc)$/i, "");
      if (!base) base = "output";
    }

    // å¦‚æœç”¨æˆ·ç»™çš„åå­—æ²¡æœ‰åç¼€ï¼Œå°±æ‹¼ä¸Šè‡ªåŠ¨è¯†åˆ«å‡ºæ¥çš„ ext
    if (!/\.[^\.]+$/.test(base)) {
      base = base + ext;
    }

    const blob = new Blob([plainBytes], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = base;
    a.click();
    URL.revokeObjectURL(a.href);
  } catch (e) {
    console.error(e);
    alert("è§£å¯†å¤±è´¥ï¼š" + e.message);
  }
};

</script>
</body>
</html>
